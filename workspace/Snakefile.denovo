rule denovodist:
    input:
        expand("data/mash/k{ksize}-s{sketchsize}/{set}.dist",
                ksize=config["denovodist"]["ksize"],
                sketchsize=config["denovodist"]["mash_sketchsize"],
                set=[s for s, v in SAMPLESETS.items() if len(v) >=3]),
        expand("data/kwip/k{ksize}-s{sketchsize}/{set}.dist",
                ksize=config["denovodist"]["ksize"],
                sketchsize=config["denovodist"]["kwip_sketchsize"],
                set=[s for s, v in SAMPLESETS.items() if len(v) >=3]),

#--------------------------------------------------------------------------------
#-                               de novo distance                               -
#--------------------------------------------------------------------------------

rule mashsketch:
    input:
        lambda wc: expand("data/reads/samples/{sample}.fastq.gz",
                          sample=SAMPLESETS[wc.set]),
    output:
        "data/mash/k{ksize}-s{sketchsize}/{set}.msh"
    log:
        "data/log/mash/sketch/k{ksize}-s{sketchsize}-{set}.log"
    threads: 16
    shell:
        " mash sketch"
        "   -k {wildcards.ksize}"
        "   -s {wildcards.sketchsize}"
        "   -p {threads}"
        "   -o data/mash/k{wildcards.ksize}-s{wildcards.sketchsize}/{wildcards.set}"
        "   {input}"
        " >{log} 2>&1"


rule mash:
    input:
        "data/mash/k{ksize}-s{sketchsize}/{set}.msh"
    output:
        dist="data/mash/k{ksize}-s{sketchsize}/{set}.mashdist",
    log:
        "data/log/mash/dist/k{ksize}-s{sketchsize}-{set}.log"
    threads: 16
    shell:
        "mash dist"
        "   -p {threads}"
        "   {input} {input}" # needs it twice
        " >{output}"
        " 2>{log}"

localrules: mashdist
rule mashdist:
    input:
        "data/mash/k{ksize}-s{sketchsize}/{set}.mashdist"
    output:
        "data/mash/k{ksize}-s{sketchsize}/{set}.dist"
    run:
        from collections import defaultdict
        from os.path import basename
        def fname2id(fname):
            fname = basename(fname)
            exts = [".gz", ".fastq", ".fq"]
            for ext in exts:
                if fname.endswith(ext):
                    fname = fname[:-len(ext)]
            return fname

        dists = defaultdict(dict)
        with open(input[0]) as fh:
            for line in fh:
                dist = line.strip().split('\t')
                id1 = fname2id(dist[0])
                id2 = fname2id(dist[1])
                dist = float(dist[2])
                dists[id1][id2] = dist

        with open(output[0], 'w') as ofile:
            ids = [''] + list(sorted(dists.keys()))
            print(*ids, sep='\t', file=ofile)
            for id1, row in sorted(dists.items()):
                rowdists = [it[1] for it in sorted(row.items())]
                print(id1, *rowdists, sep='\t', file=ofile)

rule countsketch:
    input:
        "data/reads/samples/{sample}.fastq.gz",
    output:
        ct="data/kwip/sketch/k{ksize}-s{sketchsize}/{sample}.ct.gz",
        info="data/kwip/sketch/k{ksize}-s{sketchsize}/{sample}.ct.gz.info",
        tsv="data/kwip/sketch/k{ksize}-s{sketchsize}/{sample}.ct.gz.info.tsv",
    log:
        "data/log/kwip/sketch/k{ksize}-s{sketchsize}-{sample}.log"
    threads:
        4
    shell:
        "load-into-counting.py"
        "   -N 1"
        "   -x {wildcards.sketchsize}"
        "   -k {wildcards.ksize}"
        "   -b"
        "   -f"
        "   -s tsv"
        "   -T {threads}"
        "   {output.ct}"
        "   {input}"
        " >{log} 2>&1"

rule kwip:
    input:
        lambda wc: expand("data/kwip/sketch/k{ksize}-s{sketchsize}/{sample}.ct.gz",
                            ksize=wc.ksize, sketchsize=wc.sketchsize,
                            sample=SAMPLESETS[wc.set]),
    output:
        d="data/kwip/k{ksize}-s{sketchsize}/{set}.dist",
        k="data/kwip/k{ksize}-s{sketchsize}/{set}.kern",
    log:
        "data/log/kwip/dist/k{ksize}-s{sketchsize}-{set}.log"
    threads:
        8
    shell:
        "kwip"
        " -d {output.d}"
        " -k {output.k}"
        " -t {threads}"
        " {input}"
        " >{log} 3>&1"

rule unique_kmers:
    input:
        expand("data/reads/libraries/{run}.fastq.gz", run=LIB2SAMP),
    output:
        "data/readstats/unique-kmers.tsv",
    threads:
        16
    params:
        kmersize=31,
    log:
        "data/log/readstats/unique-kmers.log",
    shell:
        "( kdm-unique-kmers.py"
        "    -t {threads}"
        "    -k {params.kmersize}"
        "    {input}"
        "    >{output}"
        " ) 2>{log}"

