import snkmk
configfile: "config.yml"

shell.prefix = "set -xeuo pipefail; "

LIB2SAMP, SAMP2LIB = snkmk.make_lib2sample2lib()
LIB2RUN = snkmk.make_lib2run()
SAMPLESETS = {"all_samples": list(SAMP2LIB.keys())}

localrules: qc, map, varcall, denovodist, all

wildcard_constraints:
    run="[^/]+",
    lib="[^/]+",
    aligner="[^/]+",
    sample="[^/]+",
    ref="[^/]+",

rule qc:
    input:
        ["data/reads/runs/{run}/{lib}.fastq.gz".format(run=r, lib=l)
		for l, runs in LIB2RUN.items()
		for r in runs],
        "data/readstats/readnum.tsv",

rule map:
    input:
        expand("data/alignments/{aligner}/{ref}/{sample}.bam",
               ref=config["mapping"]["ref"],
               aligner=config["mapping"]["aligners"],
               sample=SAMP2LIB)


rule all:
    input:
        rules.qc.input,
        rules.map.input,


#localrules: qcreads
rule qcreads:
    input:
        r1="rawdata/runs/{run}/{lib}_R1.fastq.gz",
        r2="rawdata/runs/{run}/{lib}_R2.fastq.gz",
    output:
        reads="data/reads/runs/{run}/{lib}.fastq.gz",
    log:
        log="data/log/adapterremoval/{run}/{lib}.log",
        settings="data/stats/adapterremoval/{run}/{lib}.txt",
    threads:
        1
    params:
        adp1=config["qc"]["adapter1"],
        adp2=config["qc"]["adapter2"],
        minqual=config["qc"]["minqual"],
    shell:
        "( AdapterRemoval"
        "   --file1 {input.r1}"
        "   --file2 {input.r2}"
        "   --adapter1 {params.adp1}"
        "   --adapter2 {params.adp2}"
        "   --combined-output"
        "   --interleaved-output"
        "   --trimns"
        "   --trimqualities"
        "   --trimwindows 10"
        "   --minquality {params.minqual}"
        "   --threads {threads}"
        "   --settings {log.settings}"
        "   --output1 /dev/stdout"
        " | seqhax pairs"
        "   -l 20"
        "   -b >(gzip >{output.reads})"
        "   /dev/stdin"
        ") >{log.log} 2>&1"


rule read_count:
    input:
        ["data/reads/runs/{run}/{lib}.fastq.gz".format(run=r, lib=l)
		for l, runs in LIB2RUN.items()
		for r in runs],
    output:
        "data/readstats/readnum.tsv",
    threads:
        16
    log:
        "data/log/readstats/seqhax-stats.log",
    shell:
        "( seqhax stats"
        "    -t {threads}"
        "    {input}"
        "    >{output}"
        " ) 2>{log}"

rule ngmap:
    input:
        reads=["data/reads/runs/{run}/{lib}.fastq.gz".format(run=r, lib=l)
		for l, runs in LIB2RUN.items()
		for r in runs],
        ref=lambda wc: config['refs'][wc.ref]
    output:
        bam="data/alignments/ngm/{ref}/byrun/{run}/{lib}.bam",
        bai="data/alignments/ngm/{ref}/byrun/{run}/{lib}.bam.bai",
    log:
        "data/log/ngm/{ref}/{run}/{lib}.log"
    threads:
        4
    shell:
        "( ngm"
        "   -q <(zcat {input.reads})"
        "   --paired --broken-pairs"
        "   -r {input.ref}"
        "   -t {threads}"
        "   --rg-id {wildcards.run}_{wildcards.lib}"
        "   --rg-sm {wildcards.sample}"
        "   --very-sensitive"
        " | samtools view -Suh -"
        " | samtools sort"
        "   -T ${{TMPDIR:-/tmp}}/{wildcards.run}_{wildcards.lib}"
        "   -@ {threads}"
        "   -m 1G"
        "   -o {output.bam}"
        "   -" # stdin
        " && samtools index {output.bam}"
        " ) >{log} 2>&1"

rule bwamem:
    input:
        reads=["data/reads/runs/{run}/{lib}.fastq.gz".format(run=r, lib=l)
		for l, runs in LIB2RUN.items()
		for r in runs],
        ref=lambda wc: config['refs'][wc.ref]
    output:
        bam="data/alignments/bwa/{ref}/byrun/{run}/{lib}.bam",
        bai="data/alignments/bwa/{ref}/byrun/{run}/{lib}.bam.bai",
    log:
        "data/log/bwa/{ref}/{run}/{lib}.log"
    threads:
        4
    shell:
        "( bwa mem"
        "   -p" # paired input
        "   -t {threads}"
        "   -R '@RG\\tID:{wildcards.run}_{wildcards.lib}\\tSM:{wildcards.sample}'"
        "   {input.ref}"
        "   <(zcat {input.reads})"
        " | samtools view -Suh -"
        " | samtools sort"
        "   -T ${{TMPDIR:-/tmp}}/{wildcards.sample}"
        "   -@ {threads}"
        "   -m 1G"
        "   -o {output.bam}"
        "   -" # stdin
        " && samtools index {output.bam}"
        " ) >{log} 2>&1"

rule mergebam_samp:
    input:
        lambda wc: ["data/alignments/{aln}/{ref}/byrun/{run}/{lib}.bam".format(
                            run=r, lib=l, aln=wc.aligner, ref=wc.ref)
	                for l in SAMP2LIB[wc.sample] for r in LIB2RUN[l]]
    output:
        bam="data/alignments/{aligner}/{ref}/{sample}.bam",
        bai="data/alignments/{aligner}/{ref}/{sample}.bam.bai",
    log:
        "data/log/mergesamplebam/{aligner}/{ref}/{sample}.log"
    threads: 1
    shell:
        "( samtools merge"
        "   -@ {threads}"
        "   {output.bam}"
        "   {input}"
        " && samtools index {output.bam}"
        " ) >{log} 2>&1"


localrules: bamlist
rule bamlist:
    input:
        lambda wc: expand("data/alignments/{aligner}/{sample}.bam",
                          aligner=wc.aligner, ref=wc.ref, sample=SAMPLESETS[wc.sampleset]),

    output:
        "data/bamlists/{aligner}/{ref}/{sampleset}.bamlist",
    run:
        with open(output[0], "w") as fh:
            for s in input:
                print(s, file=fh)
